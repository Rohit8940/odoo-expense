// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//
// Enums
//
enum Role {
  ADMIN
  MANAGER
  EMPLOYEE
}

enum ExpenseStatus {
  DRAFT
  SUBMITTED
  IN_REVIEW
  APPROVED
  REJECTED
  CANCELED
}

enum ApprovalDecision {
  PENDING
  APPROVED
  REJECTED
  SKIPPED
}

enum ApprovalRuleType {
  PERCENTAGE // e.g., 60% approvers needed
  SPECIFIC_APPROVER // e.g., CFO approves; else auto-approved
  HYBRID // percentage OR specific approver
}

//
// Core
//
model Company {
  id              String   @id @default(cuid())
  name            String
  country         String // e.g., "India"
  defaultCurrency String // ISO 4217, e.g., "INR"
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  users      User[]
  categories ExpenseCategory[]
  flows      ApprovalFlow[]
  expenses   Expense[]
  policies   ApprovalPolicy[]
  auditLogs  AuditLog[]

  @@unique([name])
}

model User {
  id           String  @id @default(cuid())
  email        String  @unique
  passwordHash String
  firstName    String
  lastName     String
  role         Role
  companyId    String
  mustChangePassword Boolean @default(false)
  company      Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  managerId String?
  manager   User?   @relation("UserToManager", fields: [managerId], references: [id])
  reports   User[]  @relation("UserToManager")

  isManagerApprover Boolean @default(false)

  expenses            Expense[]          @relation("EmployeeExpenses")
  approvals           ExpenseApproval[]  @relation("ExpenseApprovalApprover") // approvals performed by this user
  flowStepsAsApprover ApprovalFlowStep[] @relation("FlowStepApprover")
  auditLogs           AuditLog[]         @relation("AuditActor")

  // back-relation for ApprovalPolicy.specificApprover
  approvalPoliciesAsSpecificApprover ApprovalPolicy[] @relation("PolicySpecificApprover")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//
// Expense + lines + receipt OCR
//
model Expense {
  id         String @id @default(cuid())
  employeeId String
  employee   User   @relation("EmployeeExpenses", fields: [employeeId], references: [id], onDelete: Cascade)

  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Money
  amount             Decimal  @db.Decimal(14, 2) // original amount
  currency           String // ISO 4217 of original amount
  amountInCompanyCcy Decimal? @db.Decimal(14, 2) // snapshot converted amount
  conversionRate     Decimal? @db.Decimal(18, 8) // snapshot rate used

  categoryId String?
  category   ExpenseCategory? @relation(fields: [categoryId], references: [id])

  description String?
  expenseDate DateTime

  status ExpenseStatus @default(DRAFT)

  // Workflow snapshot
  flowId    String? // points to the flow template used
  flow      ApprovalFlow?     @relation(fields: [flowId], references: [id])
  // approvals instantiated from the flow
  approvals ExpenseApproval[]

  // OCR + receipt
  receipt Receipt?
  lines   ExpenseLine[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([employeeId, status])
  @@index([companyId, status, expenseDate])
}

model ExpenseLine {
  id        String  @id @default(cuid())
  expenseId String
  expense   Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)

  label    String // e.g., "Lunch", "Taxi"
  amount   Decimal @db.Decimal(14, 2)
  currency String // if line-level differs
  notes    String?

  createdAt DateTime @default(now())
}

model ExpenseCategory {
  id        String  @id @default(cuid())
  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  name        String
  isActive    Boolean  @default(true)
  // limits or policy hints
  perTxnLimit Decimal? @db.Decimal(14, 2)

  expenses Expense[]

  createdAt DateTime @default(now())

  @@unique([companyId, name])
}

model Receipt {
  id        String  @id @default(cuid())
  expenseId String  @unique
  expense   Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)

  fileUrl      String? // storage location
  // OCR extraction snapshot
  ocrRawText   String?
  merchantName String?
  amount       Decimal?  @db.Decimal(14, 2)
  currency     String?
  purchaseDate DateTime?
  vatAmount    Decimal?  @db.Decimal(14, 2)
  taxNumber    String?

  createdAt DateTime @default(now())
}

//
// Approval flow templates for the company
//
model ApprovalFlow {
  id        String  @id @default(cuid())
  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  name      String
  minAmount Decimal? @db.Decimal(14, 2)
  maxAmount Decimal? @db.Decimal(14, 2)

  useManagerAsFirstApprover Boolean @default(false)
  isSequential              Boolean @default(true) // new: sequence vs parallel

  expenses  Expense[]
  policy    ApprovalPolicy?    @relation("FlowPolicy")
  steps     ApprovalFlowStep[]
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  @@unique([companyId, name])
}

model ApprovalFlowStep {
  id     String       @id @default(cuid())
  flowId String
  flow   ApprovalFlow @relation(fields: [flowId], references: [id], onDelete: Cascade)

  order          Int
  approverUserId String?
  approverUser   User?   @relation("FlowStepApprover", fields: [approverUserId], references: [id])
  approverRole   Role?
  label          String?

  isFinalGate Boolean @default(false)
  isRequired  Boolean @default(true) // new: mandatory approver

  @@unique([flowId, order])
}

//
// Conditional approval policies (percentage, specific approver, hybrid)
// Applied at flow level. Evaluated on the set of steps instantiated.
//
model ApprovalPolicy {
  id        String  @id @default(cuid())
  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // make flowId unique so upsert(where: { flowId }) works
  flowId String       @unique
  flow   ApprovalFlow @relation("FlowPolicy", fields: [flowId], references: [id], onDelete: Cascade)

  type               ApprovalRuleType
  requiredPercent    Int?
  specificApproverId String?
  specificApprover   User?            @relation("PolicySpecificApprover", fields: [specificApproverId], references: [id])

  active    Boolean  @default(true)
  createdAt DateTime @default(now())
}

//
// Runtime approvals per expense
//
model ExpenseApproval {
  id        String  @id @default(cuid())
  expenseId String
  expense   Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)

  stepOrder      Int // copied from template order
  approverUserId String? // resolved concrete approver
  approverUser   User?   @relation("ExpenseApprovalApprover", fields: [approverUserId], references: [id])

  approverRole Role? // if queued to a role pool
  decision     ApprovalDecision @default(PENDING)
  comments     String?
  decidedAt    DateTime?

  createdAt DateTime @default(now())

  @@index([expenseId, stepOrder])
}

//
// Audit helpers (optional but useful)
//
model AuditLog {
  id        String  @id @default(cuid())
  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  actorId String?
  actor   User?   @relation("AuditActor", fields: [actorId], references: [id])

  entityType String // "Expense" | "User" | "Flow" | etc.
  entityId   String
  action     String // "CREATE" | "UPDATE" | "APPROVE" | "REJECT" | ...
  metadata   Json?

  createdAt DateTime @default(now())

  @@index([companyId, entityType, entityId])
}
